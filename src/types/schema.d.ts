/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type CartoSymJSONSchema = Style;
export type BoolExpression =
  | AndOrExpression
  | NotExpression
  | ComparisonPredicate
  | SpatialPredicate
  | TemporalPredicate
  | ArrayPredicate
  | FunctionCall
  | ConditionalExpression
  | boolean;
export type ComparisonPredicate =
  | BinaryComparisonPredicate
  | IsLikePredicate
  | TextOpPredicate
  | IsBetweenPredicate
  | IsInListPredicate
  | IsNullPredicate;
/**
 * @minItems 2
 * @maxItems 2
 */
export type ScalarOperands = [unknown, unknown];
export type IsLikeOperands = unknown[];
/**
 * @minItems 3
 * @maxItems 3
 */
export type IsBetweenOperands = [NumericExpression, NumericExpression, NumericExpression];
export type NumericExpression =
  | ArithmeticExpression
  | BitwiseLogical
  | BitwiseShift
  | BitwiseNot
  | number
  | PropertyRef
  | SystemIdentifier
  | FunctionCall
  | ConditionalExpression;
/**
 * @minItems 2
 * @maxItems 2
 */
export type ArithmeticOperands = [
  (
    | ArithmeticExpression
    | BitwiseLogical
    | BitwiseShift
    | BitwiseNot
    | PropertyRef
    | SystemIdentifier
    | FunctionCall
    | ConditionalExpression
    | number
  ),
  (
    | ArithmeticExpression
    | BitwiseLogical
    | BitwiseShift
    | BitwiseNot
    | PropertyRef
    | SystemIdentifier
    | FunctionCall
    | ConditionalExpression
    | number
  )
];
export type BitwiseOperand =
  | ArithmeticExpression
  | BitwiseLogical
  | BitwiseShift
  | BitwiseNot
  | PropertyRef
  | SystemIdentifier
  | FunctionCall
  | ConditionalExpression
  | number
  | HexNumber;
export type CharacterExpression =
  | Casei
  | Accenti
  | LowerUpperCase
  | Concatenate
  | Substitute
  | Format
  | string
  | PropertyRef
  | SystemIdentifier
  | FunctionCall
  | ConditionalExpression;
export type GeomExpression = SpatialInstance | PropertyRef | SystemIdentifier | FunctionCall | ConditionalExpression;
export type SpatialInstance =
  | GeometryLiteral
  | BboxLiteral
  | GeometryManipulationBinary
  | GeometryManipulationUnary
  | GeometryBuffer;
export type GeometryLiteral =
  | GeoJSONPoint
  | GeoJSONLineString
  | GeoJSONPolygon
  | GeoJSONMultiPoint
  | GeoJSONMultiLineString
  | GeoJSONMultiPolygon;
export type Bbox = Bbox1 & Bbox2;
export type Bbox1 = {
  [k: string]: unknown;
};
export type Bbox2 = number[];
export type TemporalExpression =
  | TemporalInstance
  | PropertyRef
  | SystemIdentifier
  | FunctionCall
  | ConditionalExpression;
export type TemporalInstance = InstantInstance | IntervalInstance;
export type InstantInstance = DateInstant | TimestampInstant;
export type DateString = string;
export type TimestampString = string;
/**
 * @minItems 2
 * @maxItems 2
 */
export type IntervalArray = [
  InstantString | ".." | PropertyRef | SystemIdentifier | FunctionCall | ConditionalExpression,
  InstantString | ".." | PropertyRef | SystemIdentifier | FunctionCall | ConditionalExpression
];
export type InstantString = DateString | TimestampString;
export type Array = (
  | CharacterExpression
  | NumericExpression
  | {
      [k: string]: unknown;
    }
  | GeomExpression
  | TemporalExpression
  | Array
)[];
export type HexNumber = string;
export type InListOperands = unknown[];
export type IsNullOperand =
  | CharacterExpression
  | NumericExpression
  | {
      [k: string]: unknown;
    }
  | GeomExpression
  | TemporalExpression;
export type SpatialOperands = unknown[];
export type TemporalOperands = unknown[];
/**
 * @minItems 2
 * @maxItems 2
 */
export type ArrayArguments = [
  Array | PropertyRef | SystemIdentifier | FunctionCall | ConditionalExpression,
  Array | PropertyRef | SystemIdentifier | FunctionCall | ConditionalExpression
];
export type ZeroToOne = NumericExpression | number;
export type Fill =
  | IdOrFnExpression
  | {
      alter?: boolean;
      color?: Color;
      opacity?: ZeroToOne;
      pattern?: Graphic;
      gradient?: Gradient;
      stippleStyle?: StippleStyle;
      hatchStyle?: HatchStyle;
      [k: string]: unknown;
    };
export type IdOrFnExpression = SystemIdentifier | PropertyRef | FunctionCall | ConditionalExpression;
export type Color =
  | IdOrFnExpression
  | {
      r?: ColorComponent0To255;
      g?: ColorComponent0To255;
      b?: ColorComponent0To255;
      alter?: boolean;
      [k: string]: unknown;
    }
  | [ColorComponent0To255, ColorComponent0To255, ColorComponent0To255]
  | WebColorName;
export type ColorComponent0To255 = NumericExpression | number;
export type WebColorName =
  | "black"
  | "dimGray"
  | "dimGrey"
  | "gray"
  | "grey"
  | "darkGray"
  | "darkGrey"
  | "silver"
  | "lightGray"
  | "lightGrey"
  | "gainsboro"
  | "whiteSmoke"
  | "white"
  | "rosyBrown"
  | "indianRed"
  | "brown"
  | "fireBrick"
  | "lightCoral"
  | "maroon"
  | "darkRed"
  | "red"
  | "snow"
  | "mistyRose"
  | "salmon"
  | "tomato"
  | "darkSalmon"
  | "coral"
  | "orangeRed"
  | "lightSalmon"
  | "sienna"
  | "seaShell"
  | "chocolate"
  | "saddleBrown"
  | "sandyBrown"
  | "peachPuff"
  | "peru"
  | "linen"
  | "bisque"
  | "darkOrange"
  | "burlyWood"
  | "tan"
  | "antiqueWhite"
  | "navajoWhite"
  | "blanchedAlmond"
  | "papayaWhip"
  | "moccasin"
  | "orange"
  | "wheat"
  | "oldLace"
  | "floralWhite"
  | "darkGoldenrod"
  | "goldenrod"
  | "cornsilk"
  | "gold"
  | "khaki"
  | "lemonChiffon"
  | "paleGoldenrod"
  | "darkKhaki"
  | "beige"
  | "lightGoldenRodYellow"
  | "olive"
  | "yellow"
  | "lightYellow"
  | "ivory"
  | "oliveDrab"
  | "yellowGreen"
  | "darkOliveGreen"
  | "greenYellow"
  | "chartreuse"
  | "lawnGreen"
  | "darkSeaGreen"
  | "forestGreen"
  | "limeGreen"
  | "lightGreen"
  | "paleGreen"
  | "darkGreen"
  | "green"
  | "lime"
  | "honeyDew"
  | "seaGreen"
  | "mediumSeaGreen"
  | "springGreen"
  | "mintCream"
  | "mediumSpringGreen"
  | "mediumAquaMarine"
  | "aquamarine"
  | "turquoise"
  | "lightSeaGreen"
  | "mediumTurquoise"
  | "darkSlateGray"
  | "darkSlateGrey"
  | "paleTurquoise"
  | "teal"
  | "darkCyan"
  | "aqua"
  | "cyan"
  | "lightCyan"
  | "azure"
  | "darkTurquoise"
  | "cadetBlue"
  | "powderBlue"
  | "lightBlue"
  | "deepSkyBlue"
  | "skyBlue"
  | "lightSkyBlue"
  | "steelBlue"
  | "aliceBlue"
  | "dodgerBlue"
  | "slateGray"
  | "slateGrey"
  | "lightSlateGray"
  | "lightSlateGrey"
  | "lightSteelBlue"
  | "cornflowerBlue"
  | "royalBlue"
  | "midnightBlue"
  | "lavender"
  | "navy"
  | "darkBlue"
  | "mediumBlue"
  | "blue"
  | "ghostWhite"
  | "slateBlue"
  | "darkSlateBlue"
  | "mediumSlateBlue"
  | "mediumPurple"
  | "blueViolet"
  | "indigo"
  | "darkOrchid"
  | "darkViolet"
  | "mediumOrchid"
  | "thistle"
  | "plum"
  | "violet"
  | "purple"
  | "darkMagenta"
  | "magenta"
  | "fuschia"
  | "orchid"
  | "mediumVioletRed"
  | "deepPink"
  | "hotPink"
  | "lavenderBlush"
  | "paleVioletRed"
  | "crimson"
  | "pink"
  | "lightPink";
export type Graphic = IdOrFnExpression | Image | Shape | Text | Model | Marker | GraphicInstance;
export type Image = AbstractGraphic & {
  type: "Image";
  image: Resource;
  hotSpot?: UnitPoint;
  tint?: Color;
  blackTint?: Color;
  alphaThreshold?: ZeroToOne;
  [k: string]: unknown;
};
export type UnitPoint =
  | IdOrFnExpression
  | [UnitValue, UnitValue]
  | [UnitValue, UnitValue, UnitValue]
  | {
      x?: UnitValue;
      y?: UnitValue;
      z?: UnitValue;
      alter?: boolean;
      [k: string]: unknown;
    };
export type UnitValue =
  | NumericExpression
  | {
      px: NumericExpression;
      [k: string]: unknown;
    }
  | {
      mm: NumericExpression;
      [k: string]: unknown;
    }
  | {
      cm: NumericExpression;
      [k: string]: unknown;
    }
  | {
      in: NumericExpression;
      [k: string]: unknown;
    }
  | {
      pt: NumericExpression;
      [k: string]: unknown;
    }
  | {
      em: NumericExpression;
      [k: string]: unknown;
    }
  | {
      pc: NumericExpression;
      [k: string]: unknown;
    }
  | {
      m: NumericExpression;
      [k: string]: unknown;
    }
  | {
      ft: NumericExpression;
      [k: string]: unknown;
    };
export type Angle =
  | NumericExpression
  | {
      deg: NumericExpression;
      [k: string]: unknown;
    }
  | {
      rad: NumericExpression;
      [k: string]: unknown;
    };
export type Scale2D =
  | IdOrFnExpression
  | [NumericExpression, NumericExpression]
  | {
      x?: NumericExpression;
      y?: NumericExpression;
      alter?: boolean;
      [k: string]: unknown;
    };
export type Orientation3D =
  | IdOrFnExpression
  | [NumericExpression, NumericExpression, NumericExpression, NumericExpression]
  | {
      w?: NumericExpression;
      x?: NumericExpression;
      y?: NumericExpression;
      z?: NumericExpression;
      alter?: boolean;
      [k: string]: unknown;
    }
  | {
      yaw?: NumericExpression;
      pitch?: NumericExpression;
      roll?: NumericExpression;
      alter?: boolean;
      [k: string]: unknown;
    };
export type Scale3D =
  | IdOrFnExpression
  | [NumericExpression, NumericExpression, NumericExpression]
  | {
      x?: NumericExpression;
      y?: NumericExpression;
      z?: NumericExpression;
      alter?: boolean;
      [k: string]: unknown;
    };
export type Shape = Dot | Arc | Path | Rectangle | Circle | Ellipse | SectorArc | ChordArc | ClosedPath;
export type Dot = AbstractShape & {
  type: "Dot";
  [k: string]: unknown;
};
export type AbstractShape = AbstractGraphic & {
  type: string;
  stroke?: Stroke;
  outline?: ShapeOutline;
  [k: string]: unknown;
};
export type Stroke =
  | IdOrFnExpression
  | (StrokeStyling & {
      casing?: StrokeStyling;
      centerLine?: StrokeStyling;
      join?: StrokeJoin;
      cap?: StrokeCap;
      dashPattern?: DashPattern;
      pattern?: Graphic;
      [k: string]: unknown;
    });
export type StrokeStyling =
  | IdOrFnExpression
  | {
      alter?: boolean;
      color?: Color;
      opacity?: ZeroToOne;
      width?: UnitValue;
      [k: string]: unknown;
    };
export type StrokeJoin = IdOrFnExpression | ("miter" | "round" | "bevel");
export type StrokeCap = IdOrFnExpression | ("butt" | "round" | "square");
export type DashPattern =
  | IdOrFnExpression
  | number[]
  | {
      index: number;
      value: number;
      [k: string]: unknown;
    };
export type ShapeOutline =
  | IdOrFnExpression
  | {
      alter?: boolean;
      thickness?: UnitValue;
      opacity?: ZeroToOne;
      color?: Color;
      [k: string]: unknown;
    };
export type Arc = AbstractArc & {
  type: "Arc";
  [k: string]: unknown;
};
export type AbstractArc = AbstractShape & {
  center?: UnitPoint;
  radius: UnitValue;
  startAngle: Angle;
  deltaAngle: Angle;
  [k: string]: unknown;
};
export type Path = AbstractPath & {
  type: "Path";
  [k: string]: unknown;
};
export type AbstractPath = AbstractShape & {
  nodes: PathNodes;
  [k: string]: unknown;
};
export type PathNodes =
  | ArrayExpression
  | [UnitPoint, ...UnitPoint[]]
  | {
      index: number;
      value: UnitPoint;
      [k: string]: unknown;
    };
export type ArrayExpression = (Array | PropertyRef | SystemIdentifier | FunctionCall | ConditionalExpression)[];
export type Rectangle = ClosedShape & {
  type: "Rectangle";
  topLeft: UnitPoint;
  bottomRight: UnitPoint;
  [k: string]: unknown;
};
export type ClosedShape = AbstractShape & {
  fill?: Fill;
  [k: string]: unknown;
};
export type Circle = ClosedShape & {
  type: "Circle";
  center?: UnitPoint;
  radius?: UnitValue;
  [k: string]: unknown;
};
export type Ellipse = ClosedShape & {
  type: "Ellipse";
  center?: UnitPoint;
  radii:
    | [UnitValue, UnitValue]
    | {
        x?: UnitValue;
        y?: UnitValue;
        alter?: boolean;
        [k: string]: unknown;
      };
  [k: string]: unknown;
};
export type SectorArc = ClosedShape &
  AbstractArc & {
    type: "SectorArc";
    [k: string]: unknown;
  };
export type ChordArc = ClosedShape &
  AbstractArc & {
    type: "ChordArc";
    [k: string]: unknown;
  };
export type ClosedPath = AbstractPath &
  ClosedShape & {
    type?: "ClosedPath";
    innerNodes?:
      | ArrayExpression
      | PathNodes[]
      | {
          index: number;
          value: PathNodes;
          [k: string]: unknown;
        };
    [k: string]: unknown;
  };
export type Text = AbstractGraphic & {
  type: "Text";
  text: CharacterExpression;
  font?: Font;
  alignment?: TextAlignment;
  [k: string]: unknown;
};
export type Font =
  | IdOrFnExpression
  | {
      alter?: boolean;
      face?: CharacterExpression;
      size?: NumericExpression;
      bold?: BoolExpression;
      italic?: BoolExpression;
      underline?: BoolExpression;
      color?: Color;
      opacity?: ZeroToOne;
      outline?: FontOutline;
      [k: string]: unknown;
    };
export type FontOutline =
  | IdOrFnExpression
  | {
      alter?: boolean;
      size?: NumericExpression;
      opacity?: ZeroToOne;
      color?: Color;
      [k: string]: unknown;
    };
export type TextAlignment =
  | IdOrFnExpression
  | [unknown, unknown]
  | {
      hAlignment?: HAlignment;
      vAlignment?: VAlignment;
      alter?: boolean;
      [k: string]: unknown;
    };
export type HAlignment = IdOrFnExpression | ("left" | "center" | "right");
export type VAlignment = IdOrFnExpression | ("top" | "middle" | "bottom");
export type Model = AbstractGraphic & {
  type: "Model";
  model: Resource;
  [k: string]: unknown;
};
export type Marker =
  | IdOrFnExpression
  | (AbstractGraphic & {
      elements: GraphicArray;
      [k: string]: unknown;
    });
export type GraphicArray =
  | ArrayExpression
  | Graphic[]
  | {
      index: number;
      value: Graphic;
      [k: string]: unknown;
    };
export type GraphicInstance = AbstractGraphic & {
  type: "GraphicInstance";
  element: Graphic;
  [k: string]: unknown;
};
export type Gradient =
  | IdOrFnExpression
  | {
      alter?: boolean;
      type?: "linear" | "radial";
      keys?:
        | ColorKey[]
        | {
            index: number;
            value: ColorKey;
            [k: string]: unknown;
          };
      [k: string]: unknown;
    };
export type Percent = NumericExpression | number;
export type StippleStyle = IdOrFnExpression | ("light" | "medium" | "heavy");
export type HatchStyle = IdOrFnExpression | ("forward" | "backward" | "xCross" | "cross");
export type Label = Marker & {
  placement?: LabelPlacement;
  [k: string]: unknown;
};
export type LabelPlacement =
  | IdOrFnExpression
  | {
      alter?: boolean;
      priority?: NumericExpression;
      minSpacing?: NumericExpression;
      maxSpacing?: NumericExpression;
      [k: string]: unknown;
    };
export type Color0To1 =
  | IdOrFnExpression
  | {
      r?: ZeroToOne;
      g?: ZeroToOne;
      b?: ZeroToOne;
      alter?: boolean;
      [k: string]: unknown;
    }
  | [ZeroToOne, ZeroToOne, ZeroToOne]
  | WebColorName;
export type ColorMap =
  | IdOrFnExpression
  | [[unknown, unknown] | [unknown, unknown, unknown], ...([unknown, unknown] | [unknown, unknown, unknown])[]];
export type OpacityMap =
  | IdOrFnExpression
  | [[unknown, unknown] | [unknown, unknown, unknown], ...([unknown, unknown] | [unknown, unknown, unknown])[]];
export type HillShading =
  | IdOrFnExpression
  | {
      factor?: NumericExpression;
      sun?: AzimuthElevation;
      colorMap?: HsColorMap;
      opacityMap?: HsOpacityMap;
      alter?: boolean;
      [k: string]: unknown;
    };
export type AzimuthElevation =
  | IdOrFnExpression
  | {
      azimuth?: Angle;
      elevation?: Angle;
      alter?: boolean;
      [k: string]: unknown;
    };
export type HsColorMap =
  | IdOrFnExpression
  | [[unknown, unknown] | [unknown, unknown, unknown], ...([unknown, unknown] | [unknown, unknown, unknown])[]];
export type HsOpacityMap =
  | IdOrFnExpression
  | [[unknown, unknown] | [unknown, unknown, unknown], ...([unknown, unknown] | [unknown, unknown, unknown])[]];

export interface Style {
  $comment?: string;
  $include?: string | [string, ...string[]];
  metadata?: {
    $comment?: string;
    title?: string;
    abstract?: string;
    authors?: string[];
    geoDataClasses?: string[];
    [k: string]: unknown;
  };
  stylingRules: StylingRule[];
  $variables?: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
export interface StylingRule {
  $comment?: string;
  selector?: BoolExpression;
  symbolizer?: Symbolizer;
  nestedRules?: StylingRule[];
  [k: string]: unknown;
}
export interface AndOrExpression {
  op: "and" | "or";
  /**
   * @minItems 2
   */
  args: [
    {
      [k: string]: unknown;
    },
    {
      [k: string]: unknown;
    },
    ...{
      [k: string]: unknown;
    }[]
  ];
  [k: string]: unknown;
}
export interface NotExpression {
  op: "not";
  /**
   * @minItems 1
   * @maxItems 1
   */
  args: [
    {
      [k: string]: unknown;
    }
  ];
  [k: string]: unknown;
}
export interface BinaryComparisonPredicate {
  op: "=" | "<>" | "<" | ">" | "<=" | ">=";
  args: ScalarOperands;
  [k: string]: unknown;
}
export interface IsLikePredicate {
  op: "like";
  args: IsLikeOperands;
  [k: string]: unknown;
}
export interface TextOpPredicate {
  op: "contains" | "startsWith" | "endsWith";
  args: unknown[];
  [k: string]: unknown;
}
export interface IsBetweenPredicate {
  op: "between";
  args: IsBetweenOperands;
  [k: string]: unknown;
}
export interface ArithmeticExpression {
  op: "+" | "-" | "*" | "/" | "^";
  args: ArithmeticOperands;
  [k: string]: unknown;
}
export interface BitwiseLogical {
  op: "bitAnd" | "bitOr" | "bitXor";
  /**
   * @minItems 2
   * @maxItems 2
   */
  args: [BitwiseOperand, BitwiseOperand];
  [k: string]: unknown;
}
export interface BitwiseShift {
  op: "<<" | ">>";
  /**
   * @minItems 2
   * @maxItems 2
   */
  args: [BitwiseOperand, BitwiseOperand];
  [k: string]: unknown;
}
export interface BitwiseNot {
  op: "bitNot";
  /**
   * @minItems 1
   * @maxItems 1
   */
  args: [BitwiseOperand];
  [k: string]: unknown;
}
export interface PropertyRef {
  property: string;
  [k: string]: unknown;
}
export interface SystemIdentifier {
  sysId:
    | "dataLayer"
    | "dataLayer.id"
    | "dataLayer.type"
    | "dataLayer.features"
    | "dataLayer.featuresGeometry"
    | "dataLayer.featuresGeometryDimensions"
    | "feature"
    | "feature.id"
    | "feature.geometry"
    | "feature.geometryDimensions"
    | "vis"
    | "vis.sd"
    | "vis.date"
    | "vis.date.day"
    | "vis.date.month"
    | "vis.date.year"
    | "vis.dateTime"
    | "vis.dateTime.date"
    | "vis.dateTime.date.day"
    | "vis.dateTime.date.month"
    | "vis.dateTime.date.year"
    | "vis.dateTime.time"
    | "vis.dateTime.time.hour"
    | "vis.dateTime.time.minutes"
    | "vis.dateTime.time.seconds"
    | "vis.timeInterval"
    | "vis.timeInterval.start"
    | "vis.timeInterval.start.date"
    | "vis.timeInterval.start.date.day"
    | "vis.timeInterval.start.date.month"
    | "vis.timeInterval.start.date.year"
    | "vis.timeInterval.start.time"
    | "vis.timeInterval.start.time.hour"
    | "vis.timeInterval.start.time.minutes"
    | "vis.timeInterval.start.time.seconds"
    | "vis.timeInterval.end"
    | "vis.timeInterval.end.date"
    | "vis.timeInterval.end.date.day"
    | "vis.timeInterval.end.date.month"
    | "vis.timeInterval.end.date.year"
    | "vis.timeInterval.end.time"
    | "vis.timeInterval.end.time.hour"
    | "vis.timeInterval.end.time.minutes"
    | "vis.timeInterval.end.time.seconds"
    | "vis.timeOfDay"
    | "vis.timeOfDay.hour"
    | "vis.timeOfDay.minutes"
    | "vis.timeOfDay.seconds";
  [k: string]: unknown;
}
export interface FunctionCall {
  op: string;
  args: (
    | CharacterExpression
    | NumericExpression
    | {
        [k: string]: unknown;
      }
    | GeomExpression
    | TemporalExpression
    | Array
  )[];
  [k: string]: unknown;
}
export interface Casei {
  op: "casei";
  /**
   * @minItems 1
   * @maxItems 1
   */
  args: [CharacterExpression];
  [k: string]: unknown;
}
export interface Accenti {
  op: "accenti";
  /**
   * @minItems 1
   * @maxItems 1
   */
  args: [CharacterExpression];
  [k: string]: unknown;
}
export interface LowerUpperCase {
  op: "lowerCase" | "upperCase";
  /**
   * @minItems 1
   * @maxItems 1
   */
  args: [CharacterExpression];
  [k: string]: unknown;
}
export interface Concatenate {
  op: "concatenate";
  /**
   * @minItems 2
   */
  args: [CharacterExpression, CharacterExpression, ...CharacterExpression[]];
  [k: string]: unknown;
}
export interface Substitute {
  name?: "substitute";
  /**
   * @minItems 3
   * @maxItems 3
   */
  args: [CharacterExpression, CharacterExpression, CharacterExpression];
  [k: string]: unknown;
}
export interface Format {
  name?: "format";
  /**
   * @minItems 1
   */
  args: [
    (
      | CharacterExpression
      | NumericExpression
      | {
          [k: string]: unknown;
        }
      | GeomExpression
      | TemporalExpression
      | Array
    ),
    ...(
      | CharacterExpression
      | NumericExpression
      | {
          [k: string]: unknown;
        }
      | GeomExpression
      | TemporalExpression
      | Array
    )[]
  ];
  [k: string]: unknown;
}
export interface GeoJSONPoint {
  type: "Point";
  /**
   * @minItems 2
   */
  coordinates: [number, number, ...number[]];
  /**
   * @minItems 4
   */
  bbox?: [number, number, number, number, ...number[]];
  [k: string]: unknown;
}
export interface GeoJSONLineString {
  type: "LineString";
  /**
   * @minItems 2
   */
  coordinates: [[number, number, ...number[]], [number, number, ...number[]], ...[number, number, ...number[]][]];
  /**
   * @minItems 4
   */
  bbox?: [number, number, number, number, ...number[]];
  [k: string]: unknown;
}
export interface GeoJSONPolygon {
  type: "Polygon";
  coordinates: [
    [number, number, ...number[]],
    [number, number, ...number[]],
    [number, number, ...number[]],
    [number, number, ...number[]],
    ...[number, number, ...number[]][]
  ][];
  /**
   * @minItems 4
   */
  bbox?: [number, number, number, number, ...number[]];
  [k: string]: unknown;
}
export interface GeoJSONMultiPoint {
  type: "MultiPoint";
  coordinates: [number, number, ...number[]][];
  /**
   * @minItems 4
   */
  bbox?: [number, number, number, number, ...number[]];
  [k: string]: unknown;
}
export interface GeoJSONMultiLineString {
  type: "MultiLineString";
  coordinates: [[number, number, ...number[]], [number, number, ...number[]], ...[number, number, ...number[]][]][];
  /**
   * @minItems 4
   */
  bbox?: [number, number, number, number, ...number[]];
  [k: string]: unknown;
}
export interface GeoJSONMultiPolygon {
  type: "MultiPolygon";
  coordinates: [
    [number, number, ...number[]],
    [number, number, ...number[]],
    [number, number, ...number[]],
    [number, number, ...number[]],
    ...[number, number, ...number[]][]
  ][][];
  /**
   * @minItems 4
   */
  bbox?: [number, number, number, number, ...number[]];
  [k: string]: unknown;
}
export interface BboxLiteral {
  bbox: Bbox;
  [k: string]: unknown;
}
export interface GeometryManipulationBinary {
  name?: "s_intersection" | "s_union" | "s_difference" | "s_symDifference";
  /**
   * @minItems 2
   * @maxItems 2
   */
  args: [SpatialInstance, SpatialInstance];
  [k: string]: unknown;
}
export interface GeometryManipulationUnary {
  name?: "s_convexHull" | "s_envelope";
  /**
   * @minItems 1
   * @maxItems 1
   */
  args: [SpatialInstance];
  [k: string]: unknown;
}
export interface GeometryBuffer {
  name?: "s_buffer";
  /**
   * @minItems 2
   * @maxItems 2
   */
  args: [unknown, unknown];
  [k: string]: unknown;
}
export interface ConditionalExpression {
  op: "?:";
  /**
   * @minItems 3
   * @maxItems 3
   */
  args: [unknown, unknown, unknown];
  [k: string]: unknown;
}
export interface DateInstant {
  date: DateString;
  [k: string]: unknown;
}
export interface TimestampInstant {
  timestamp: TimestampString;
  [k: string]: unknown;
}
export interface IntervalInstance {
  interval: IntervalArray;
  [k: string]: unknown;
}
export interface IsInListPredicate {
  op: "in";
  args: InListOperands;
  [k: string]: unknown;
}
export interface IsNullPredicate {
  op: "isNull";
  args: IsNullOperand;
  [k: string]: unknown;
}
export interface SpatialPredicate {
  op:
    | "s_contains"
    | "s_crosses"
    | "s_disjoint"
    | "s_equals"
    | "s_intersects"
    | "s_overlaps"
    | "s_touches"
    | "s_within"
    | "s_covers"
    | "s_coveredBy";
  args: SpatialOperands;
  [k: string]: unknown;
}
export interface TemporalPredicate {
  op:
    | "t_after"
    | "t_before"
    | "t_contains"
    | "t_disjoint"
    | "t_during"
    | "t_equals"
    | "t_finishedBy"
    | "t_finishes"
    | "t_intersects"
    | "t_meets"
    | "t_metBy"
    | "t_overlappedBy"
    | "t_overlaps"
    | "t_startedBy"
    | "t_starts";
  args: TemporalOperands;
  [k: string]: unknown;
}
export interface ArrayPredicate {
  op: "a_containedBy" | "a_contains" | "a_equals" | "a_overlaps";
  args: ArrayArguments;
  [k: string]: unknown;
}
export interface Symbolizer {
  $comment?: string;
  visibility?: BoolExpression;
  opacity?: ZeroToOne;
  zOrder?: NumericExpression;
  fill?: Fill;
  stroke?: Stroke;
  marker?: Marker;
  label?: Label;
  colorChannels?: Color0To1;
  alphaChannel?: ZeroToOne;
  singleChannel?: ZeroToOne;
  colorMap?: ColorMap;
  opacityMap?: OpacityMap;
  hillShading?: HillShading;
  [k: string]: unknown;
}
export interface AbstractGraphic {
  alter?: boolean;
  position?: UnitPoint;
  opacity?: ZeroToOne;
  transform?: Transform2D;
  transform3D?: Transform3D;
  [k: string]: unknown;
}
export interface Transform2D {
  alter?: boolean;
  orientation?: Angle;
  scaling?: Scale2D;
  translation?: UnitPoint;
  [k: string]: unknown;
}
export interface Transform3D {
  alter?: boolean;
  orientation?: Orientation3D;
  scaling?: Scale3D;
  translation?: UnitPoint;
  [k: string]: unknown;
}
export interface Resource {
  alter?: boolean;
  uri?: CharacterExpression;
  path?: CharacterExpression;
  id?: CharacterExpression;
  type?: CharacterExpression;
  ext?: CharacterExpression;
  sprite?: CharacterExpression;
  [k: string]: unknown;
}
export interface ColorKey {
  alter?: boolean;
  percent?: Percent;
  color?: Color;
  opacity?: ZeroToOne;
  [k: string]: unknown;
}
